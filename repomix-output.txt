This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
media/
  codicon.css
  main.css
  main.js
  reset.css
  vscode.css
src/
  cache/
    PromptCache.ts
  config/
    config.json
    ConfigManager.ts
    defaultConfig.ts
    SettingsWebview.ts
    templates.json
  context/
    ContextAnalyzer.ts
  prompts/
    systemPrompt.ts
  templates/
    TemplateEngine.ts
  test/
    extension.test.ts
  extension.ts
.gitignore
.vscode-test.mjs
.vscodeignore
CHANGELOG.md
eslint.config.mjs
package.json
README.md
tsconfig.json
vsc-extension-quickstart.md

================================================================
Files
================================================================

================
File: media/codicon.css
================
@font-face {
    font-family: "codicon";
    src: url("./codicon.ttf") format("truetype");
}

================
File: media/main.css
================
/* Base Layout */
body {
    padding: 10px;
    display: flex;
    flex-direction: column;
    height: calc(100vh - 20px);
}

/* Header Styles */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

h2 {
    margin-bottom: 10px;
    flex-shrink: 0;
}

/* Settings Button */
.icon-button {
    background: none;
    border: none;
    padding: 5px;
    cursor: pointer;
    color: var(--vscode-foreground);
    display: flex;
    align-items: center;
    justify-content: center;
}

.icon-button:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
    border-radius: 3px;
}

.codicon {
    font-family: codicon;
    font-size: 16px;
    line-height: 16px;
}

.codicon-gear:before {
    content: "\ea6c";
}

/* Conversation Area */
.conversation-area {
    flex-grow: 1;
    border: 1px solid var(--vscode-editorWidget-border, var(--vscode-separator-foreground));
    padding: 8px;
    margin-bottom: 10px;
    overflow-y: auto;
    background-color: var(--vscode-textBlockQuote-background, var(--vscode-editorWidget-background));
    border-radius: 3px;
}

/* Message Styles */
.message {
    margin-bottom: 8px;
    padding: 6px 10px;
    border-radius: 5px;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-width: 80%;
    clear: both;
}

.user-message {
    background-color: var(--vscode-list-activeSelectionBackground, #094771);
    color: var(--vscode-list-activeSelectionForeground, white);
    float: right;
}

.assistant-message {
    background-color: var(--vscode-list-inactiveSelectionBackground, var(--vscode-editorWidget-background, #37373d));
    color: var(--vscode-editorWidget-foreground, var(--vscode-foreground));
    float: left;
}

.assistant-message.error {
    color: var(--vscode-errorForeground);
    border: 1px solid var(--vscode-inputValidation-errorBorder);
}

/* Thinking Indicator */
.thinking-indicator {
    font-style: italic;
    color: var(--vscode-descriptionForeground);
    float: left;
    clear: both;
}

/* Optimized Prompt Styles */
.final-prompt, .optimized-prompt {
    border-left: 3px solid var(--vscode-textLink-foreground);
    margin-top: 10px;
    padding-left: 10px;
}

/* Copy Button Styles */
.copy-button-container {
    margin-top: 10px;
    text-align: right;
    clear: both;
}

.copy-button {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 6px 12px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 12px;
    display: inline-block; /* Changed from 'none' to make it visible */
}

.copy-button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

/* Input Area */
.input-area {
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    margin-top: 5px;
}

textarea#prompt-input {
    width: calc(100% - 16px);
    margin-bottom: 5px;
    resize: vertical;
    min-height: 40px;
    max-height: 150px;
}

/* Button Group */
.button-group {
    display: flex;
    gap: 5px;
}

.button-group button {
    flex-grow: 1;
}

================
File: media/main.js
================
// media/main.js

(function () {
    const vscode = acquireVsCodeApi();
    const promptInput = document.getElementById('prompt-input');
    const sendButton = document.getElementById('send-button');
    const clearButton = document.getElementById('clear-button');
    const conversationArea = document.getElementById('conversation-area');
    let lastOptimizedPrompt = '';

    // --- Helper Functions ---
    function addThinkingIndicator() {
        removeThinkingIndicator(); // Remove any existing indicator first
        const thinkingDiv = document.createElement('div');
        thinkingDiv.classList.add('message', 'assistant-message', 'thinking-indicator');
        thinkingDiv.textContent = 'Thinking...';
        conversationArea.appendChild(thinkingDiv);
        conversationArea.scrollTop = conversationArea.scrollHeight;
    }

    function removeThinkingIndicator() {
        const thinkingIndicator = document.querySelector('.thinking-indicator');
        if (thinkingIndicator) {
            thinkingIndicator.remove();
        }
    }

    function addMessageToUI(role, text, isOptimizedPrompt = false) {
        removeThinkingIndicator();

        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', role === 'user' ? 'user-message' : 'assistant-message');

        const contentDiv = document.createElement('div');
        contentDiv.textContent = text;
        messageDiv.appendChild(contentDiv);

        // Only show copy button for optimized prompts
        if (isOptimizedPrompt && text.includes('Optimized Prompt:')) {
            const optimizedPrompt = text.split('Optimized Prompt:')[1].trim();
            lastOptimizedPrompt = optimizedPrompt;
            
            const copyButtonDiv = document.createElement('div');
            copyButtonDiv.classList.add('copy-button-container');
            
            const copyBtn = document.createElement('button');
            copyBtn.textContent = 'Copy Prompt';
            copyBtn.classList.add('copy-button');
            copyBtn.onclick = () => {
                vscode.postMessage({
                    type: 'copyToClipboard',
                    value: optimizedPrompt
                });
            };
            
            copyButtonDiv.appendChild(copyBtn);
            messageDiv.appendChild(copyButtonDiv);
        }

        conversationArea.appendChild(messageDiv);
        conversationArea.scrollTop = conversationArea.scrollHeight;
    }

    // --- Event Listeners ---
    if (sendButton && promptInput) {
        sendButton.addEventListener('click', () => {
            const promptText = promptInput.value.trim();
            if (promptText) {
                addMessageToUI('user', promptText);
                vscode.postMessage({
                    type: 'optimizePrompt',
                    value: promptText
                });
                promptInput.value = '';
            }
        });
    }

    if (promptInput) {
        promptInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendButton.click();
            }
        });
    }

    if (clearButton) {
        clearButton.addEventListener('click', () => {
            vscode.postMessage({ type: 'clearChat' });
        });
    }

    // --- Handle Messages from Extension Host ---
    window.addEventListener('message', event => {
        const message = event.data;

        switch (message.type) {
            case 'addMessage':
                {
                    promptInput.disabled = false;
                    sendButton.disabled = false;
                    addMessageToUI(message.role, message.value, message.isOptimizedPrompt);
                    break;
                }
            case 'showLoading':
                {
                    promptInput.disabled = true;
                    sendButton.disabled = true;
                    addThinkingIndicator();
                    break;
                }
            case 'clearChat':
                {
                    conversationArea.innerHTML = '';
                    promptInput.value = '';
                    promptInput.disabled = false;
                    sendButton.disabled = false;
                    lastOptimizedPrompt = '';
                    break;
                }
            case 'showError':
                {
                    removeThinkingIndicator();
                    addMessageToUI('assistant', `Error: ${message.value}`);
                    promptInput.disabled = false;
                    sendButton.disabled = false;
                    break;
                }
        }
    });
}());

================
File: media/reset.css
================
/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
	display: block;
}
body {
	line-height: 1;
}
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}

================
File: media/vscode.css
================
/* Styles to match VS Code's look and feel */
body {
	background-color: var(--vscode-editor-background);
	color: var(--vscode-editor-foreground);
	font-family: var(--vscode-font-family);
	font-weight: var(--vscode-font-weight);
	font-size: var(--vscode-font-size);
	padding: 10px;
}

a {
	color: var(--vscode-textLink-foreground);
	text-decoration: none;
}

a:hover {
	color: var(--vscode-textLink-activeForeground);
	text-decoration: underline;
}

button {
	border: none;
	padding: 8px 12px;
	background-color: var(--vscode-button-background);
	color: var(--vscode-button-foreground);
	cursor: pointer;
	border-radius: 2px;
	font-family: var(--vscode-font-family);
	font-weight: var(--vscode-font-weight);
	font-size: var(--vscode-font-size);
}

button:hover {
	background-color: var(--vscode-button-hoverBackground);
}

button:focus {
	outline: 1px solid var(--vscode-focusBorder);
	outline-offset: 2px;
}

input[type="text"],
textarea {
	display: block;
	width: calc(100% - 20px); /* Account for padding */
	padding: 8px;
	margin-bottom: 10px;
	border: 1px solid var(--vscode-input-border, var(--vscode-dropdown-border));
	background-color: var(--vscode-input-background);
	color: var(--vscode-input-foreground);
	font-family: var(--vscode-font-family);
	font-weight: var(--vscode-font-weight);
	font-size: var(--vscode-font-size);
	border-radius: 2px;
}

input[type="text"]::placeholder,
textarea::placeholder {
	color: var(--vscode-input-placeholderForeground);
}

input[type="text"]:focus,
textarea:focus {
	outline: 1px solid var(--vscode-focusBorder);
	border-color: var(--vscode-focusBorder);
}

h2, h3 {
    margin-top: 15px;
    margin-bottom: 10px;
    font-weight: bold;
}

hr {
    border: none;
    border-top: 1px solid var(--vscode-editorWidget-border, var(--vscode-separator-foreground));
    margin: 15px 0;
}

================
File: src/cache/PromptCache.ts
================
// src/cache/PromptCache.ts

interface CacheEntry {
    prompt: string;
    response: string;
    timestamp: number;
    context: string;
}

export class PromptCache {
    private cache: Map<string, CacheEntry>;
    private readonly maxEntries: number;
    private readonly ttl: number; // Time to live in milliseconds

    constructor(maxEntries = 100, ttlMinutes = 60) {
        this.cache = new Map();
        this.maxEntries = maxEntries;
        this.ttl = ttlMinutes * 60 * 1000;
    }

    public get(prompt: string, context: string): string | undefined {
        const key = this.generateKey(prompt, context);
        const entry = this.cache.get(key);
        
        if (!entry) {
            return undefined;
        }

        if (this.isExpired(entry)) {
            this.cache.delete(key);
            return undefined;
        }

        return entry.response;
    }

    public set(prompt: string, response: string, context: string): void {
        const key = this.generateKey(prompt, context);
        
        if (this.cache.size >= this.maxEntries) {
            this.evictOldest();
        }

        this.cache.set(key, {
            prompt,
            response,
            timestamp: Date.now(),
            context
        });
    }

    private generateKey(prompt: string, context: string): string {
        return `${prompt}:${context}`;
    }

    private isExpired(entry: CacheEntry): boolean {
        return Date.now() - entry.timestamp > this.ttl;
    }

    private evictOldest(): void {
        let oldestKey: string | undefined;
        let oldestTimestamp = Infinity;

        for (const [key, entry] of this.cache.entries()) {
            if (entry.timestamp < oldestTimestamp) {
                oldestTimestamp = entry.timestamp;
                oldestKey = key;
            }
        }

        if (oldestKey) {
            this.cache.delete(oldestKey);
        }
    }
}

================
File: src/config/config.json
================
{
  "api": {
    "defaultProvider": "openai",
    "maxTokens": 2000,
    "temperature": 0.7,
    "openai": {
      "endpoint": "https://api.openai.com/v1/chat/completions",
      "apiKey": "",
      "model": "gpt-4"
    },
    "openrouter": {
      "endpoint": "https://openrouter.ai/api/v1/chat/completions",
      "apiKey": "",
      "model": "openai/gpt-4"
    },
    "anthropic": {
      "endpoint": "https://api.anthropic.com/v1/complete",
      "apiKey": "",
      "model": "claude-2"
    },
    "custom": {
      "endpoint": "",
      "apiKey": "",
      "model": ""
    }
  },
    
    "cache": {
      "enabled": true,
      "maxEntries": 100,
      "ttlMinutes": 60,
      "excludePatterns": [
        "sensitive*",
        "personal*"
      ]
    },
  
    "templates": {
      "enabled": true,
      "customTemplatesPath": "./templates",
      "defaultTemplate": "general",
      "autoDetect": true
    },
  
    "context": {
      "analysis": {
        "enabled": true,
        "scanDepth": 2,
        "excludeFolders": [
          "node_modules",
          "dist",
          ".git"
        ],
        "includePackageJson": true,
        "includeGitInfo": true
      },
      "workspace": {
        "maxFileScanSize": 1000000,
        "fileExtensions": [
          ".ts",
          ".js",
          ".tsx",
          ".jsx",
          ".py",
          ".java",
          ".cpp"
        ]
      }
    },
  
    "ui": {
      "theme": "auto",
      "maxConversationHistory": 50,
      "showLineNumbers": true,
      "autoComplete": true,
      "suggestions": {
        "enabled": true,
        "maxSuggestions": 5,
        "triggerCharacters": ["@", "/", "#"]
      }
    },
  
    "features": {
      "autoOptimize": {
        "enabled": true,
        "triggerLength": 50,
        "delay": 500
      },
      "export": {
        "formats": ["json", "markdown", "txt"],
        "includeMeta": true
      },
      "collaboration": {
        "enabled": false,
        "shareLinks": false
      }
    },
  
    "security": {
      "sanitizePrompts": true,
      "maxPromptLength": 5000,
      "sensitivePatterns": [
        "password",
        "api[_-]?key",
        "secret",
        "token"
      ]
    },
  
    "telemetry": {
      "enabled": false,
      "anonymizeData": true,
      "collectUsageStats": false
    },
  
    "experimental": {
      "streamingResponse": false,
      "multimodalPrompts": false,
      "advancedContextAnalysis": false
    }
  }

================
File: src/config/ConfigManager.ts
================
// src/config/ConfigManager.ts

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { defaultConfig } from './defaultConfig';

export interface Config {
    api: {
        defaultProvider: string;
        maxTokens: number;
        temperature: number;
        openai: ProviderConfig;
        openrouter: ProviderConfig;
        anthropic: ProviderConfig;
        custom: ProviderConfig;
    };
    cache: {
        enabled: boolean;
        maxEntries: number;
        ttlMinutes: number;
        excludePatterns: string[];
    };
    templates: {
        enabled: boolean;
        customTemplatesPath: string;
        defaultTemplate: string;
        autoDetect: boolean;
    };
    context: {
        analysis: {
            enabled: boolean;
            scanDepth: number;
            excludeFolders: string[];
            includePackageJson: boolean;
            includeGitInfo: boolean;
        };
        workspace: {
            maxFileScanSize: number;
            fileExtensions: string[];
        };
    };
    ui: {
        theme: 'light' | 'dark' | 'auto';
        maxConversationHistory: number;
        showLineNumbers: boolean;
        autoComplete: boolean;
        suggestions: {
            enabled: boolean;
            maxSuggestions: number;
            triggerCharacters: string[];
        };
    };
}

export class ConfigManager {
    private static instance: ConfigManager;
    private config: Config;
    private readonly configPath: string;

    private constructor(context: vscode.ExtensionContext) {
        this.configPath = path.join(context.globalStorageUri.fsPath, 'config.json');
        this.config = this.loadConfig();
    }

    public static getInstance(context: vscode.ExtensionContext): ConfigManager {
        if (!ConfigManager.instance) {
            ConfigManager.instance = new ConfigManager(context);
        }
        return ConfigManager.instance;
    }

    private loadConfig(): Config {
        try {
            if (fs.existsSync(this.configPath)) {
                const userConfig = JSON.parse(fs.readFileSync(this.configPath, 'utf-8'));
                return this.mergeConfigs(defaultConfig, userConfig);
            }
            // If no config file exists, create one with default settings
            this.saveConfig(defaultConfig);
            return defaultConfig;
        } catch (error) {
            console.error('Error loading config:', error);
            return defaultConfig;
        }
    }

    private mergeConfigs(defaultConfig: Config, userConfig: Partial<Config>): Config {
        const merged = { ...defaultConfig };

        // Merge API configuration
        if (userConfig.api) {
            merged.api = {
                ...defaultConfig.api,
                ...userConfig.api,
                openai: { ...defaultConfig.api.openai, ...userConfig.api?.openai },
                openrouter: { ...defaultConfig.api.openrouter, ...userConfig.api?.openrouter },
                anthropic: { ...defaultConfig.api.anthropic, ...userConfig.api?.anthropic },
                custom: { ...defaultConfig.api.custom, ...userConfig.api?.custom }
            };
        }

        // Merge cache configuration
        if (userConfig.cache) {
            merged.cache = {
                ...defaultConfig.cache,
                ...userConfig.cache
            };
        }

        // Merge templates configuration
        if (userConfig.templates) {
            merged.templates = {
                ...defaultConfig.templates,
                ...userConfig.templates
            };
        }

        // Merge context configuration
        if (userConfig.context) {
            merged.context = {
                analysis: {
                    ...defaultConfig.context.analysis,
                    ...userConfig.context?.analysis
                },
                workspace: {
                    ...defaultConfig.context.workspace,
                    ...userConfig.context?.workspace
                }
            };
        }

        // Merge UI configuration
        if (userConfig.ui) {
            merged.ui = {
                ...defaultConfig.ui,
                ...userConfig.ui,
                suggestions: {
                    ...defaultConfig.ui.suggestions,
                    ...userConfig.ui?.suggestions
                }
            };
        }

        return merged;
    }

    public async updateConfig(newConfig: Partial<Config>): Promise<void> {
        this.config = this.mergeConfigs(this.config, newConfig);
        await this.saveConfig(this.config);
    }

    private async saveConfig(config: Config): Promise<void> {
        try {
            const configDir = path.dirname(this.configPath);
            if (!fs.existsSync(configDir)) {
                fs.mkdirSync(configDir, { recursive: true });
            }
            fs.writeFileSync(this.configPath, JSON.stringify(config, null, 2));
        } catch (error) {
            console.error('Error saving config:', error);
            throw error;
        }
    }

    public getConfig(): Config {
        return this.config;
    }

    public get<K extends keyof Config>(key: K): Config[K] {
        return this.config[key];
    }

    public async resetToDefaults(): Promise<void> {
        this.config = defaultConfig;
        await this.saveConfig(this.config);
    }

    public validateConfiguration(): string[] {
        const errors: string[] = [];
        const provider = this.config.api.defaultProvider;
        const providerConfig = this.config.api[provider as keyof typeof this.config.api];

        if (!providerConfig) {
            errors.push(`Selected provider ${provider} is not properly configured`);
        } else {
            if (!providerConfig.endpoint) {
                errors.push(`API endpoint not configured for ${provider}`);
            }
            if (!providerConfig.apiKey) {
                errors.push(`API key not configured for ${provider}`);
            }
            if (!providerConfig.model) {
                errors.push(`Model not selected for ${provider}`);
            }
        }

        return errors;
    }

    public getApiEndpoint(): string {
        const provider = this.config.api.defaultProvider;
        const providerConfig = this.config.api[provider as keyof typeof this.config.api];
        return providerConfig?.endpoint || '';
    }
}

================
File: src/config/defaultConfig.ts
================
// src/config/defaultConfig.ts

export const defaultConfig = {
    api: {
        defaultProvider: 'openai',
        maxTokens: 2000,
        temperature: 0.7,
        openai: {
            endpoint: 'https://api.openai.com/v1/chat/completions',
            apiKey: '',
            model: 'gpt-4'
        },
        openrouter: {
            endpoint: 'https://openrouter.ai/api/v1/chat/completions',
            apiKey: '',
            model: 'openai/gpt-4'
        },
        anthropic: {
            endpoint: 'https://api.anthropic.com/v1/complete',
            apiKey: '',
            model: 'claude-2'
        },
        custom: {
            endpoint: '',
            apiKey: '',
            model: ''
        }
    },
    cache: {
        enabled: true,
        maxEntries: 100,
        ttlMinutes: 60,
        excludePatterns: []
    },
    templates: {
        enabled: true,
        customTemplatesPath: './templates',
        defaultTemplate: 'general',
        autoDetect: true
    },
    context: {
        analysis: {
            enabled: true,
            scanDepth: 2,
            excludeFolders: ['node_modules', 'dist', '.git'],
            includePackageJson: true,
            includeGitInfo: true
        },
        workspace: {
            maxFileScanSize: 1000000,
            fileExtensions: ['.ts', '.js', '.tsx', '.jsx', '.py', '.java', '.cpp']
        }
    },
    ui: {
        theme: 'auto',
        maxConversationHistory: 50,
        showLineNumbers: true,
        autoComplete: true,
        suggestions: {
            enabled: true,
            maxSuggestions: 5,
            triggerCharacters: ['@', '/', '#']
        }
    }
};

================
File: src/config/SettingsWebview.ts
================
// src/config/SettingsWebview.ts

import * as vscode from 'vscode';
import { ConfigManager } from './ConfigManager';

export class SettingsWebview {
    public static readonly viewType = 'aiPromptOptimizerSettings';
    private readonly _panel: vscode.WebviewPanel;
    private readonly _configManager: ConfigManager;

    private constructor(panel: vscode.WebviewPanel, configManager: ConfigManager) {
        this._panel = panel;
        this._configManager = configManager;
        this._update();
        this._setWebviewMessageListener();
    }

    public static render(extensionUri: vscode.Uri, configManager: ConfigManager) {
        const panel = vscode.window.createWebviewPanel(
            SettingsWebview.viewType,
            'AI Prompt Optimizer Settings',
            vscode.ViewColumn.One,
            {
                enableScripts: true,
                localResourceRoots: [extensionUri]
            }
        );

        return new SettingsWebview(panel, configManager);
    }

    private _update() {
        const config = this._configManager.getConfig();
        this._panel.webview.html = this._getHtmlForWebview(config);
    }

    private _setWebviewMessageListener() {
        this._panel.webview.onDidReceiveMessage(async (message) => {
            switch (message.type) {
                case 'saveConfig':
                    try {
                        console.log('Saving configuration:', {
                            provider: message.value.api.defaultProvider,
                            hasApiKey: !!message.value.api[message.value.api.defaultProvider]?.apiKey,
                            endpoint: message.value.api[message.value.api.defaultProvider]?.endpoint
                        });
    
                        await this._configManager.updateConfig(message.value);
                        
                        // Verify the configuration was saved
                        const newConfig = this._configManager.getConfig();
                        console.log('Configuration saved:', {
                            provider: newConfig.api.defaultProvider,
                            hasApiKey: !!newConfig.api[newConfig.api.defaultProvider]?.apiKey,
                            endpoint: newConfig.api[newConfig.api.defaultProvider]?.endpoint
                        });
    
                        vscode.window.showInformationMessage('Configuration saved successfully!');
                    } catch (error) {
                        console.error('Failed to save configuration:', error);
                        vscode.window.showErrorMessage(`Failed to save configuration: ${error.message}`);
                    }
                    break;
            }
        });
    }

    private _getHtmlForWebview(config: any): string {
        return `<!DOCTYPE html>
        <html>
        <head>
            <style>
                body { 
                    padding: 20px; 
                    color: var(--vscode-foreground);
                    font-family: var(--vscode-font-family);
                }
                .form-group { 
                    margin-bottom: 15px; 
                }
                label { 
                    display: block; 
                    margin-bottom: 5px; 
                }
                input, select, textarea { 
                    width: 100%; 
                    padding: 5px;
                    background-color: var(--vscode-input-background);
                    color: var(--vscode-input-foreground);
                    border: 1px solid var(--vscode-input-border);
                }
                .section { 
                    margin-bottom: 20px; 
                    border-bottom: 1px solid var(--vscode-panel-border); 
                    padding-bottom: 20px; 
                }
                button {
                    background-color: var(--vscode-button-background);
                    color: var(--vscode-button-foreground);
                    border: none;
                    padding: 8px 16px;
                    cursor: pointer;
                }
                button:hover {
                    background-color: var(--vscode-button-hoverBackground);
                }
                .provider-config {
                    margin-left: 20px;
                    padding: 10px;
                    border-left: 2px solid var(--vscode-panel-border);
                }
                .hidden {
                    display: none;
                }
                .checkbox-group {
                    margin: 10px 0;
                }
                .checkbox-label {
                    display: flex;
                    align-items: center;
                    gap: 5px;
                }
                .checkbox-label input[type="checkbox"] {
                    width: auto;
                }
            </style>
        </head>
        <body>
            <h2>AI Prompt Optimizer Settings</h2>
            <form id="settingsForm">
                <div class="section">
                    <h3>API Configuration</h3>
                    <div class="form-group">
                        <label>Provider:</label>
                        <select id="provider" name="provider">
                            <option value="openai" ${config.api.defaultProvider === 'openai' ? 'selected' : ''}>OpenAI</option>
                            <option value="openrouter" ${config.api.defaultProvider === 'openrouter' ? 'selected' : ''}>OpenRouter</option>
                            <option value="anthropic" ${config.api.defaultProvider === 'anthropic' ? 'selected' : ''}>Anthropic</option>
                            <option value="custom" ${config.api.defaultProvider === 'custom' ? 'selected' : ''}>Custom</option>
                        </select>
                    </div>

                    <!-- OpenAI Configuration -->
                    <div id="openai-config" class="provider-config ${config.api.defaultProvider === 'openai' ? '' : 'hidden'}">
                        <div class="form-group">
                            <label>OpenAI API Key:</label>
                            <input type="password" id="openaiApiKey" value="${config.api.openai?.apiKey || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Model:</label>
                            <select id="openaiModel">
                                <option value="gpt-4" ${config.api.openai?.model === 'gpt-4' ? 'selected' : ''}>GPT-4</option>
                                <option value="gpt-4-turbo" ${config.api.openai?.model === 'gpt-4-turbo' ? 'selected' : ''}>GPT-4 Turbo</option>
                                <option value="gpt-3.5-turbo" ${config.api.openai?.model === 'gpt-3.5-turbo' ? 'selected' : ''}>GPT-3.5 Turbo</option>
                            </select>
                        </div>
                    </div>

                    <!-- OpenRouter Configuration -->
                    <div id="openrouter-config" class="provider-config ${config.api.defaultProvider === 'openrouter' ? '' : 'hidden'}">
                        <div class="form-group">
                            <label>OpenRouter API Key:</label>
                            <input type="password" id="openrouterApiKey" value="${config.api.openrouter?.apiKey || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Model:</label>
                            <select id="openrouterModel">
                                <option value="openai/gpt-4" ${config.api.openrouter?.model === 'openai/gpt-4' ? 'selected' : ''}>GPT-4</option>
                                <option value="anthropic/claude-2" ${config.api.openrouter?.model === 'anthropic/claude-2' ? 'selected' : ''}>Claude 2</option>
                                <option value="google/palm-2" ${config.api.openrouter?.model === 'google/palm-2' ? 'selected' : ''}>PaLM 2</option>
                            </select>
                        </div>
                    </div>

                    <!-- Anthropic Configuration -->
                    <div id="anthropic-config" class="provider-config ${config.api.defaultProvider === 'anthropic' ? '' : 'hidden'}">
                        <div class="form-group">
                            <label>Anthropic API Key:</label>
                            <input type="password" id="anthropicApiKey" value="${config.api.anthropic?.apiKey || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Model:</label>
                            <select id="anthropicModel">
                                <option value="claude-2" ${config.api.anthropic?.model === 'claude-2' ? 'selected' : ''}>Claude 2</option>
                                <option value="claude-instant" ${config.api.anthropic?.model === 'claude-instant' ? 'selected' : ''}>Claude Instant</option>
                            </select>
                        </div>
                    </div>

                    <!-- Custom Provider Configuration -->
                    <div id="custom-config" class="provider-config ${config.api.defaultProvider === 'custom' ? '' : 'hidden'}">
                        <div class="form-group">
                            <label>API Endpoint URL:</label>
                            <input type="text" id="customApiUrl" value="${config.api.custom?.endpoint || ''}" placeholder="https://api.example.com/v1/chat/completions" />
                        </div>
                        <div class="form-group">
                            <label>API Key:</label>
                            <input type="password" id="customApiKey" value="${config.api.custom?.apiKey || ''}" />
                        </div>
                        <div class="form-group">
                            <label>Model:</label>
                            <input type="text" id="customModel" value="${config.api.custom?.model || ''}" placeholder="model-name" />
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>Advanced Settings</h3>
                    <div class="form-group">
                        <label>Max Tokens:</label>
                        <input type="number" id="maxTokens" value="${config.api.maxTokens || 2000}" min="1" max="8000" />
                    </div>
                    <div class="form-group">
                        <label>Temperature:</label>
                        <input type="range" id="temperature" min="0" max="2" step="0.1" value="${config.api.temperature || 0.7}" />
                        <span id="temperatureValue">${config.api.temperature || 0.7}</span>
                    </div>
                </div>

                <div class="section">
                    <h3>Cache Settings</h3>
                    <div class="checkbox-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="cacheEnabled" ${config.cache.enabled ? 'checked' : ''} />
                            Enable Cache
                        </label>
                    </div>
                    <div class="form-group">
                        <label>Cache TTL (minutes):</label>
                        <input type="number" id="cacheTTL" value="${config.cache.ttlMinutes}" min="1" />
                    </div>
                </div>

                <button type="submit">Save Settings</button>
            </form>

            <script>
                const form = document.getElementById('settingsForm');
                const providerSelect = document.getElementById('provider');
                const temperatureInput = document.getElementById('temperature');
                const temperatureValue = document.getElementById('temperatureValue');

                // Update temperature value display
                temperatureInput.addEventListener('input', (e) => {
                    temperatureValue.textContent = e.target.value;
                });

                // Handle provider change
                providerSelect.addEventListener('change', (e) => {
                    // Hide all provider configs
                    document.querySelectorAll('.provider-config').forEach(config => {
                        config.classList.add('hidden');
                    });
                    // Show selected provider config
                    document.getElementById(e.target.value + '-config').classList.remove('hidden');
                });

                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const provider = providerSelect.value;
                    
                    const formData = {
                        api: {
                            defaultProvider: provider,
                            maxTokens: parseInt(document.getElementById('maxTokens').value),
                            temperature: parseFloat(document.getElementById('temperature').value),
                        },
                        cache: {
                            enabled: document.getElementById('cacheEnabled').checked,
                            ttlMinutes: parseInt(document.getElementById('cacheTTL').value),
                        }
                    };

                    // Add provider-specific configuration
                    switch(provider) {
                        case 'openai':
                            formData.api.openai = {
                                apiKey: document.getElementById('openaiApiKey').value,
                                model: document.getElementById('openaiModel').value
                            };
                            break;
                        case 'openrouter':
                            formData.api.openrouter = {
                                apiKey: document.getElementById('openrouterApiKey').value,
                                model: document.getElementById('openrouterModel').value
                            };
                            break;
                        case 'anthropic':
                            formData.api.anthropic = {
                                apiKey: document.getElementById('anthropicApiKey').value,
                                model: document.getElementById('anthropicModel').value
                            };
                            break;
                        case 'custom':
                            formData.api.custom = {
                                endpoint: document.getElementById('customApiUrl').value,
                                apiKey: document.getElementById('customApiKey').value,
                                model: document.getElementById('customModel').value
                            };
                            break;
                    }

                    const vscode = acquireVsCodeApi();
                    vscode.postMessage({
                        type: 'saveConfig',
                        value: formData
                    });
                });
            </script>
        </body>
        </html>`;
    }
}

================
File: src/config/templates.json
================
{
    "templates": {
        "api-endpoint": {
            "id": "api-endpoint",
            "name": "API Endpoint",
            "description": "Create an API endpoint with specific functionality",
            "template": "Create an API endpoint that:\n- Method: {{method}}\n- Path: {{path}}\n- Functionality: {{functionality}}\n- Authentication: {{auth}}\n- Response format: {{response}}\n\nConsider:\n- Input validation\n- Error handling\n- Rate limiting\n- Security best practices",
            "variables": ["method", "path", "functionality", "auth", "response"],
            "context": {
                "pattern": "api"
            }
        },
        "database-model": {
            "id": "database-model",
            "name": "Database Model",
            "description": "Create a database model with relationships",
            "template": "Create a database model for:\n- Entity: {{entity}}\n- Properties: {{properties}}\n- Relationships: {{relationships}}\n- Constraints: {{constraints}}\n\nInclude:\n- Indexes\n- Validation rules\n- Migration approach",
            "variables": ["entity", "properties", "relationships", "constraints"],
            "context": {
                "pattern": "database"
            }
        }
    }
}

================
File: src/context/ContextAnalyzer.ts
================
// src/context/ContextAnalyzer.ts

import * as vscode from 'vscode';

interface ProjectContext {
    language: string;
    framework: string[];
    dependencies: Record<string, string>;
    workspacePatterns: string[];
}

export class ContextAnalyzer {
    private context: ProjectContext;

    constructor() {
        this.context = {
            language: '',
            framework: [],
            dependencies: {},
            workspacePatterns: []
        };
    }

    public async analyzeWorkspace(): Promise<ProjectContext> {
        await this.detectLanguage();
        await this.analyzeDependencies();
        await this.detectPatterns();
        return this.context;
    }

    private async detectLanguage() {
        const activeEditor = vscode.window.activeTextEditor;
        if (activeEditor) {
            this.context.language = activeEditor.document.languageId;
        }
    }

    private async analyzeDependencies() {
        // Read package.json if exists
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders) {
            const packageJsonPath = vscode.Uri.joinPath(workspaceFolders[0].uri, 'package.json');
            try {
                const packageJsonContent = await vscode.workspace.fs.readFile(packageJsonPath);
                const packageJson = JSON.parse(packageJsonContent.toString());
                this.context.dependencies = {
                    ...packageJson.dependencies,
                    ...packageJson.devDependencies
                };
                
                // Detect frameworks
                if (this.context.dependencies['react']) {
                    this.context.framework.push('react');
                }
                if (this.context.dependencies['vue']) {
                    this.context.framework.push('vue');
                }
                // Add more framework detection...
            } catch (error) {
                console.log('No package.json found or unable to parse');
            }
        }
    }

    private async detectPatterns() {
        // Analyze workspace files for common patterns
        // This is a simplified example
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders) {
            const files = await vscode.workspace.findFiles('**/*.{ts,js,tsx,jsx}');
            // Analyze files for patterns...
        }
    }
}

================
File: src/prompts/systemPrompt.ts
================
// src/prompts/systemPrompt.ts

export const enhancedSystemPrompt = `You are an AI prompt optimizer focused on helping users create better prompts for their coding tasks. Follow these guidelines:

1. Start with a brief question to understand the user's needs. For example:
   - "What specific features would you like in your AI speaker webpage?"
   - "Are you looking for any particular functionality?"
   - "What's the main purpose of your AI speaker webpage?"

2. DO NOT provide implementation details until you understand the requirements.

3. After gathering requirements, create an optimized prompt that starts with "Optimized Prompt:"

Example good interaction:
User: "can you build an ai speaker web page"
Assistant: "I'd be happy to help! First, what specific features would you like your AI speaker webpage to have? For example, voice control, music playback, or smart home integration?"

Remember:
- Always ask questions first
- Don't provide implementation until requirements are clear
- Keep the conversation focused
- End with an optimized prompt when requirements are gathered`;

================
File: src/templates/TemplateEngine.ts
================
// src/templates/TemplateEngine.ts

interface PromptTemplate {
    id: string;
    name: string;
    description: string;
    template: string;
    variables: string[];
    context: {
        language?: string;
        framework?: string;
        pattern?: string;
    };
}

export class TemplateEngine {
    private templates: Map<string, PromptTemplate>;

    constructor() {
        this.templates = new Map();
        this.initializeDefaultTemplates();
    }

    private initializeDefaultTemplates() {
        this.addTemplate({
            id: 'react-component',
            name: 'React Component',
            description: 'Create a React component with specific features',
            template: `Create a React component that implements:
- Component name: {{componentName}}
- Features: {{features}}
- State management: {{stateManagement}}
- Props interface: {{propsInterface}}
Consider best practices for:
- Performance optimization
- Error handling
- Accessibility
- Testing approach`,
            variables: ['componentName', 'features', 'stateManagement', 'propsInterface'],
            context: {
                language: 'typescript',
                framework: 'react'
            }
        });

        // Add more default templates...
    }

    public getTemplate(id: string): PromptTemplate | undefined {
        return this.templates.get(id);
    }

    public addTemplate(template: PromptTemplate) {
        this.templates.set(template.id, template);
    }

    public applyTemplate(templateId: string, variables: Record<string, string>): string {
        const template = this.getTemplate(templateId);
        if (!template) {
            throw new Error(`Template ${templateId} not found`);
        }

        let result = template.template;
        for (const [key, value] of Object.entries(variables)) {
            result = result.replace(new RegExp(`{{${key}}}`, 'g'), value);
        }
        return result;
    }
}

================
File: src/test/extension.test.ts
================
import * as assert from 'assert';

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from 'vscode';
// import * as myExtension from '../../extension';

suite('Extension Test Suite', () => {
	vscode.window.showInformationMessage('Start all tests.');

	test('Sample test', () => {
		assert.strictEqual(-1, [1, 2, 3].indexOf(5));
		assert.strictEqual(-1, [1, 2, 3].indexOf(0));
	});
});

================
File: src/extension.ts
================
// src/extension.ts

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import axios from 'axios';
import { TemplateEngine } from './templates/TemplateEngine';
import { ContextAnalyzer } from './context/ContextAnalyzer';
import { PromptCache } from './cache/PromptCache';
import { ConfigManager } from './config/ConfigManager';
import { SettingsWebview } from './config/SettingsWebview';
import { enhancedSystemPrompt } from './prompts/systemPrompt';

export function activate(context: vscode.ExtensionContext) {
  console.log('ðŸš€ AI Prompt Optimizer extension activated!');

  // Initialize core services
  const configManager = ConfigManager.getInstance(context);

  // Initialize the view provider
  const provider = new PromptOptimizerViewProvider(
    context.extensionUri,
    configManager
  );

  // Register WebView Provider
  context.subscriptions.push(
    vscode.window.registerWebviewViewProvider(
      PromptOptimizerViewProvider.viewType,
      provider
    )
  );

  // Register Commands
  registerCommands(context, provider, configManager);

  // Setup Configuration Watcher
  setupConfigWatcher(context, configManager);
}

class PromptOptimizerViewProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = 'aiPromptOptimizerView';

  private _view?: vscode.WebviewView;
  private _conversationHistory: { role: string; content: string }[] = [];
  private templateEngine: TemplateEngine;
  private contextAnalyzer: ContextAnalyzer;
  private promptCache: PromptCache;

  constructor(
    private readonly _extensionUri: vscode.Uri,
    private readonly configManager: ConfigManager
  ) {
    this.templateEngine = new TemplateEngine();
    this.contextAnalyzer = new ContextAnalyzer();
    this.promptCache = new PromptCache(
      configManager.get('cache').maxEntries,
      configManager.get('cache').ttlMinutes
    );
  }

  public resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken,
  ) {
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    this._setupWebviewMessageListener(webviewView.webview);
  }

  private _setupWebviewMessageListener(webview: vscode.Webview) {
    webview.onDidReceiveMessage(async (data) => {
      try {
        switch (data.type) {
          case 'optimizePrompt':
            await this._handleOptimizePrompt(data.value);
            break;

          case 'clearChat':
            await this._handleClearChat();
            break;

          case 'copyToClipboard':
            await this._handleCopyToClipboard(data.value);
            break;

          case 'applyTemplate':
            await this._handleApplyTemplate(data.templateId, data.variables);
            break;

          case 'openSettings':
            await vscode.commands.executeCommand('ai-prompt-optimizer.openConfig');
            break;
        }
      } catch (error) {
        this._handleError(error);
      }
    });
  }

  private async _handleOptimizePrompt(userMessageContent: string) {
    try {
        // Remove any existing thinking indicator first
        this._view?.webview.postMessage({ type: 'removeThinking' });
        
        // Show new thinking indicator
        this._view?.webview.postMessage({ type: 'showLoading' });

        // Initialize conversation if first message
        if (this._conversationHistory.length === 0) {
            this._conversationHistory.push({ 
                role: "system", 
                content: enhancedSystemPrompt 
            });
        }

        // Add user message to history
        this._conversationHistory.push({ 
            role: "user", 
            content: userMessageContent 
        });

        // Get API response
        const aiResponseMessage = await this._optimizePromptApiCall(
            this._conversationHistory,
            {}
        );

        // Add response to history
        this._conversationHistory.push(aiResponseMessage);

        // Check if this contains an optimized prompt
        const hasOptimizedPrompt = aiResponseMessage.content.includes('Optimized Prompt:');

        // Send response to webview
        this._view?.webview.postMessage({
            type: 'addMessage',
            role: aiResponseMessage.role,
            value: aiResponseMessage.content,
            isOptimizedPrompt: hasOptimizedPrompt
        });

    } catch (error) {
        this._handleError(error);
    }
}


  private _addMessageToConversation(role: string, content: string) {
    this._view?.webview.postMessage({
      type: 'addMessage',
      role: role,
      value: content
    });
  }

  private async _optimizePromptApiCall(
    messages: { role: string; content: string }[],
    context: any
  ): Promise<{ role: string; content: string }> {
    const config = this.configManager.getConfig();
    const provider = config.api.defaultProvider;
    const providerConfig = config.api[provider as keyof typeof config.api];

    // Debug logging
    console.log('Current provider:', provider);
    console.log('API Endpoint:', this.configManager.getApiEndpoint());
    console.log('Selected model:', providerConfig?.model);
    // Don't log the full API key for security
    console.log('API Key present:', !!providerConfig?.apiKey);

    if (!providerConfig?.apiKey) {
      throw new Error('Please configure your API key in the settings (click the gear icon)');
    }

    try {
      const response = await axios.post(
        this.configManager.getApiEndpoint(),
        {
          model: providerConfig.model,
          messages: messages,
          max_tokens: config.api.maxTokens,
          temperature: config.api.temperature,
          context: context
        },
        {
          headers: {
            "Authorization": `Bearer ${providerConfig.apiKey}`,
            "Content-Type": "application/json",
            // Add OpenRouter specific headers if using OpenRouter
            ...(provider === 'openrouter' && {
              "HTTP-Referer": "https://github.com/yourusername/your-extension",
              "X-Title": "VS Code AI Prompt Optimizer"
            })
          }
        }
      );

      if (response.data?.choices?.[0]?.message) {
        return response.data.choices[0].message;
      }

      throw new Error("Unexpected API response structure");

    } catch (error: any) {
      console.error('API call error:', {
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data,
        message: error.message
      });

      // Provide more specific error messages
      if (error.response?.status === 401) {
        throw new Error('Invalid API key. Please check your API key in the settings.');
      } else if (error.response?.status === 429) {
        throw new Error('Rate limit exceeded. Please try again later.');
      } else if (error.response?.data?.error?.message) {
        throw new Error(`API Error: ${error.response.data.error.message}`);
      }

      throw new Error(`API call failed: ${error.message}`);
    }
  }

  private async _handleClearChat() {
    this._conversationHistory = [];
    this._view?.webview.postMessage({ type: 'clearChat' });
  }

  private async _handleCopyToClipboard(text: string) {
    await vscode.env.clipboard.writeText(text);
    vscode.window.showInformationMessage('Copied to clipboard!');
  }

  private async _handleApplyTemplate(templateId: string, variables: Record<string, string>) {
    try {
      const template = this.templateEngine.getTemplate(templateId);
      if (template) {
        const promptText = this.templateEngine.applyTemplate(templateId, variables);
        await this._handleOptimizePrompt(promptText);
      }
    } catch (error) {
      this._handleError(error);
    }
  }

  private _handleError(error: any) {
    const errorMessage = error.message || 'An unknown error occurred';
    console.error("Error:", error);
    vscode.window.showErrorMessage(`AI Prompt Optimizer: ${errorMessage}`);
    this._view?.webview.postMessage({
      type: 'showError',
      value: errorMessage
    });
  }

  private _getHtmlForWebview(webview: vscode.Webview): string {
    const scriptUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'main.js')
    );
    const styleResetUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'reset.css')
    );
    const styleVSCodeUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'vscode.css')
    );
    const styleMainUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'main.css')
    );
    const codiconUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'codicon.css')
    );

    const nonce = getNonce();

    return `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <link href="${styleResetUri}" rel="stylesheet">
                <link href="${styleVSCodeUri}" rel="stylesheet">
                <link href="${styleMainUri}" rel="stylesheet">
                <link href="${codiconUri}" rel="stylesheet">
                <title>AI Prompt Optimizer</title>
            </head>
            <body>
                <div class="header">
                    <h2>Optimize AI Prompt</h2>
                    <button id="settings-button" class="icon-button" title="Open Settings">
                        <i class="codicon codicon-gear"></i>
                    </button>
                </div>
                <div id="conversation-area" class="conversation-area">
                    <!-- Conversation history will be appended here by JS -->
                </div>
                <div class="input-area">
                    <textarea id="prompt-input" rows="3" placeholder="Enter your initial prompt or reply here..."></textarea>
                    <div class="button-group">
                        <button id="send-button">Send</button>
                        <button id="clear-button">Clear Chat</button>
                    </div>
                </div>
                <button id="copy-button" style="display: none;">Copy Final Prompt</button>
                <script nonce="${nonce}" src="${scriptUri}"></script>
            </body>
            </html>`;
  }
}

function registerCommands(
  context: vscode.ExtensionContext,
  provider: PromptOptimizerViewProvider,
  configManager: ConfigManager
) {
  // Register the 'Configure' command
  context.subscriptions.push(
    vscode.commands.registerCommand('ai-prompt-optimizer.openConfig', () => {
      SettingsWebview.render(context.extensionUri, configManager);
    })
  );

  // Register the 'Show View' command
  context.subscriptions.push(
    vscode.commands.registerCommand('ai-prompt-optimizer.showView', () => {
      vscode.commands.executeCommand(
        'workbench.view.extension.ai-prompt-optimizer-activitybar'
      );
    })
  );

  // Register the 'Copy Prompt' command
  context.subscriptions.push(
    vscode.commands.registerCommand('ai-prompt-optimizer.copyPrompt', async (prompt: string) => {
      await vscode.env.clipboard.writeText(prompt);
      vscode.window.showInformationMessage('Prompt copied to clipboard!');
    })
  );

  // Register the 'Reset Config' command
  context.subscriptions.push(
    vscode.commands.registerCommand('ai-prompt-optimizer.resetConfig', async () => {
      try {
        await configManager.resetToDefaults();
        vscode.window.showInformationMessage('Configuration has been reset to defaults');
      } catch (error) {
        vscode.window.showErrorMessage('Failed to reset configuration');
      }
    })
  );
}

function setupConfigWatcher(
  context: vscode.ExtensionContext,
  configManager: ConfigManager
) {
  const configWatcher = vscode.workspace.createFileSystemWatcher('**/config.json');

  configWatcher.onDidChange(async () => {
    try {
      await configManager.loadConfig();
      vscode.window.showInformationMessage(
        'AI Prompt Optimizer configuration updated'
      );
    } catch (error) {
      vscode.window.showErrorMessage(
        'Failed to reload configuration. Please check the file format.'
      );
    }
  });

  context.subscriptions.push(configWatcher);
}

function getNonce() {
  let text = '';
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}

export function deactivate() { }

================
File: .gitignore
================
out
dist
node_modules
.vscode-test/
*.vsix

================
File: .vscode-test.mjs
================
import { defineConfig } from '@vscode/test-cli';

export default defineConfig({
	files: 'out/test/**/*.test.js',
});

================
File: .vscodeignore
================
.vscode/**
.vscode-test/**
src/**
.gitignore
.yarnrc
vsc-extension-quickstart.md
**/tsconfig.json
**/eslint.config.mjs
**/*.map
**/*.ts
**/.vscode-test.*

================
File: CHANGELOG.md
================
# Change Log

All notable changes to the "ai-prompt-optimizer" extension will be documented in this file.

Check [Keep a Changelog](http://keepachangelog.com/) for recommendations on how to structure this file.

## [Unreleased]

- Initial release

================
File: eslint.config.mjs
================
import typescriptEslint from "@typescript-eslint/eslint-plugin";
import tsParser from "@typescript-eslint/parser";

export default [{
    files: ["**/*.ts"],
}, {
    plugins: {
        "@typescript-eslint": typescriptEslint,
    },

    languageOptions: {
        parser: tsParser,
        ecmaVersion: 2022,
        sourceType: "module",
    },

    rules: {
        "@typescript-eslint/naming-convention": ["warn", {
            selector: "import",
            format: ["camelCase", "PascalCase"],
        }],

        curly: "warn",
        eqeqeq: "warn",
        "no-throw-literal": "warn",
        semi: "warn",
    },
}];

================
File: package.json
================
{
  "name": "ai-prompt-optimizer",
  "displayName": "AI Prompt Optimizer",
  "description": "Optimize prompts for AI coding tools like Cursor AI and Continue Dev",
  "version": "0.0.1",
  "publisher": "mohamedhemdan",
  "engines": {
    "vscode": "^1.87.0"
  },
  "categories": [
    "Programming Languages",
    "Other"
  ],
  "activationEvents": [
    "onView:aiPromptOptimizerView"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "ai-prompt-optimizer.copyPrompt",
        "title": "Copy Optimized Prompt"
      },
      {
        "command": "ai-prompt-optimizer.showView",
        "title": "Show AI Prompt Optimizer"
      },
      {
        "command": "ai-prompt-optimizer.configure",
        "title": "AI Prompt Optimizer: Configure"
      },
      {
        "command": "ai-prompt-optimizer.openConfig",
        "title": "AI Prompt Optimizer: Open Configuration"
      },
      {
        "command": "ai-prompt-optimizer.resetConfig",
        "title": "AI Prompt Optimizer: Reset Configuration"
      }
    ],
    "viewsContainers": {
      "activitybar": [
        {
          "id": "ai-prompt-optimizer-activitybar",
          "title": "AI Prompt Optimizer",
          "icon": "$(lightbulb)"
        }
      ]
    },
    "views": {
      "ai-prompt-optimizer-activitybar": [
        {
          "id": "aiPromptOptimizerView",
          "name": "Optimize Prompt",
          "type": "webview",
          "contextualTitle": "AI Prompt Optimizer"
        }
      ]
    },
    "menus": {
      "view/title": [
        {
          "command": "ai-prompt-optimizer.openConfig",
          "when": "view == aiPromptOptimizerView",
          "group": "navigation"
        }
      ]
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run esbuild",
    "esbuild": "esbuild ./src/extension.ts --bundle --outfile=out/extension.js --external:vscode --format=cjs --platform=node --minify",
    "watch": "esbuild ./src/extension.ts --bundle --outfile=out/extension.js --external:vscode --format=cjs --platform=node --watch",
    "compile": "tsc -p ./",
    "pretest": "npm run compile && npm run lint",
    "lint": "eslint src",
    "test": "vscode-test"
  },
  "devDependencies": {
    "@types/mocha": "^10.0.10",
    "@types/node": "20.x",
    "@types/vscode": "^1.87.0",
    "@typescript-eslint/eslint-plugin": "^8.28.0",
    "@typescript-eslint/parser": "^8.28.0",
    "@vscode/test-cli": "^0.0.10",
    "@vscode/test-electron": "^2.4.1",
    "eslint": "^9.23.0",
    "typescript": "^5.8.2",
    "esbuild": "^0.23.1",
    "@types/axios": "^0.14.0"
  },
  "dependencies": {
    "axios": "^1.7.7"
  }
}

================
File: README.md
================
# ai-prompt-optimizer README

This is the README for your extension "ai-prompt-optimizer". After writing up a brief description, we recommend including the following sections.

## Features

Describe specific features of your extension including screenshots of your extension in action. Image paths are relative to this README file.

For example if there is an image subfolder under your extension project workspace:

\!\[feature X\]\(images/feature-x.png\)

> Tip: Many popular extensions utilize animations. This is an excellent way to show off your extension! We recommend short, focused animations that are easy to follow.

## Requirements

If you have any requirements or dependencies, add a section describing those and how to install and configure them.

## Extension Settings

Include if your extension adds any VS Code settings through the `contributes.configuration` extension point.

For example:

This extension contributes the following settings:

* `myExtension.enable`: Enable/disable this extension.
* `myExtension.thing`: Set to `blah` to do something.

## Known Issues

Calling out known issues can help limit users opening duplicate issues against your extension.

## Release Notes

Users appreciate release notes as you update your extension.

### 1.0.0

Initial release of ...

### 1.0.1

Fixed issue #.

### 1.1.0

Added features X, Y, and Z.

---

## Following extension guidelines

Ensure that you've read through the extensions guidelines and follow the best practices for creating your extension.

* [Extension Guidelines](https://code.visualstudio.com/api/references/extension-guidelines)

## Working with Markdown

You can author your README using Visual Studio Code. Here are some useful editor keyboard shortcuts:

* Split the editor (`Cmd+\` on macOS or `Ctrl+\` on Windows and Linux).
* Toggle preview (`Shift+Cmd+V` on macOS or `Shift+Ctrl+V` on Windows and Linux).
* Press `Ctrl+Space` (Windows, Linux, macOS) to see a list of Markdown snippets.

## For more information

* [Visual Studio Code's Markdown Support](http://code.visualstudio.com/docs/languages/markdown)
* [Markdown Syntax Reference](https://help.github.com/articles/markdown-basics/)

**Enjoy!**

================
File: tsconfig.json
================
{
	"compilerOptions": {
	  "module": "commonjs",
	  "target": "es2020",
	  "outDir": "out",
	  "rootDir": "src",
	  "sourceMap": true,
	  "strict": true
	}
}

================
File: vsc-extension-quickstart.md
================
# Welcome to your VS Code Extension

## What's in the folder

* This folder contains all of the files necessary for your extension.
* `package.json` - this is the manifest file in which you declare your extension and command.
  * The sample plugin registers a command and defines its title and command name. With this information VS Code can show the command in the command palette. It doesnâ€™t yet need to load the plugin.
* `src/extension.ts` - this is the main file where you will provide the implementation of your command.
  * The file exports one function, `activate`, which is called the very first time your extension is activated (in this case by executing the command). Inside the `activate` function we call `registerCommand`.
  * We pass the function containing the implementation of the command as the second parameter to `registerCommand`.

## Get up and running straight away

* Press `F5` to open a new window with your extension loaded.
* Run your command from the command palette by pressing (`Ctrl+Shift+P` or `Cmd+Shift+P` on Mac) and typing `Hello World`.
* Set breakpoints in your code inside `src/extension.ts` to debug your extension.
* Find output from your extension in the debug console.

## Make changes

* You can relaunch the extension from the debug toolbar after changing code in `src/extension.ts`.
* You can also reload (`Ctrl+R` or `Cmd+R` on Mac) the VS Code window with your extension to load your changes.

## Explore the API

* You can open the full set of our API when you open the file `node_modules/@types/vscode/index.d.ts`.

## Run tests

* Install the [Extension Test Runner](https://marketplace.visualstudio.com/items?itemName=ms-vscode.extension-test-runner)
* Run the "watch" task via the **Tasks: Run Task** command. Make sure this is running, or tests might not be discovered.
* Open the Testing view from the activity bar and click the Run Test" button, or use the hotkey `Ctrl/Cmd + ; A`
* See the output of the test result in the Test Results view.
* Make changes to `src/test/extension.test.ts` or create new test files inside the `test` folder.
  * The provided test runner will only consider files matching the name pattern `**.test.ts`.
  * You can create folders inside the `test` folder to structure your tests any way you want.

## Go further

* [Follow UX guidelines](https://code.visualstudio.com/api/ux-guidelines/overview) to create extensions that seamlessly integrate with VS Code's native interface and patterns.
* Reduce the extension size and improve the startup time by [bundling your extension](https://code.visualstudio.com/api/working-with-extensions/bundling-extension).
* [Publish your extension](https://code.visualstudio.com/api/working-with-extensions/publishing-extension) on the VS Code extension marketplace.
* Automate builds by setting up [Continuous Integration](https://code.visualstudio.com/api/working-with-extensions/continuous-integration).
* Integrate to the [report issue](https://code.visualstudio.com/api/get-started/wrapping-up#issue-reporting) flow to get issue and feature requests reported by users.



================================================================
End of Codebase
================================================================
